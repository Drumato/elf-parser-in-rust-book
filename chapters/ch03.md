# ELF header

ELF headerとは，  
ELF fileの先頭にある，64bytes(32bit版なら52bytes)のfieldです．

file全体の情報や，{section, segment} header tableのoffsetが格納されているので，  
ELFを扱うsoftwareは例外なくこのheaderのparseから始まります．  
ということで，ELF header parserを作ってみましょう．

binary parserを作るときは，それに対応する構造体表現を作る手法が一般的です．  
C言語でELF parserを作るときは `elf.h` を使うことでその構造体を利用できますが，  
今回は構造体を手書きすることで，ELFの構造を理解するapproachを取ってみます．

各構造体メンバの意味や用途については省略します．  
こちらの資料が参考になります．

> [elf(5) — Linux manual page](https://man7.org/linux/man-pages/man5/elf.5.html)  
> [ELF入門 - 入門ログ](https://sugawarayusuke.hatenablog.com/entry/2017/04/09/213133)

## parser

今回はparser combinator crateのnomを使ってsimpleに実装します．  
nomについての解説は行わないので，気になる方はご自身で調べてみてください．

binary parserを作るとき，  
細かいfieldのparserをまず書いていって，  
それらを組み合わせていく"combinator method"がおすすめです．  
ということで，先頭から一つずつparser sampleをお見せします．  
大体作り方は同じなので，一部のみ掲載します．  
<https://github.com/Drumato/elf-parser-in-rust-book/tree/impl> にすべて載ってあります．  

### test helper

その前に，適当にparser test helperを作っておきます．  
本来はconsumed inputの比較もすると良いと思います．  

```rust
// src/parser/header.rs
#[cfg(test)]
mod tests {
    use super::*;

    fn helper<'a, T>(
        parser: impl Fn(&'a [u8]) -> IResult<&'a [u8], T>,
        input: &'a [u8],
        expected: T,
    ) where
        T: std::fmt::Debug + PartialEq + PartialOrd,
    {
        let parse_result = parser(input);
        assert!(parse_result.is_ok());

        assert_eq!(parse_result.unwrap().1, expected);
    }

    fn helper_fail<'a, T>(parser: impl Fn(&'a [u8]) -> IResult<&'a [u8], T>, input: &'a [u8])
    where
        T: std::fmt::Debug + PartialEq + PartialOrd,
    {
        let parse_result = parser(input);
        assert!(parse_result.is_err());
    }
}
```

### magic number

```rust
// src/elf.rs
pub static ELF_MAGIC_SIGNATURE: &[u8] = b"\x7fELF";

// src/parser/header.rs
fn parse_elf_magic_number(raw: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(ELF_MAGIC_SIGNATURE)(raw)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn elf_magic_number_test() {
        helper(
            parse_elf_magic_number,
            ELF_MAGIC_SIGNATURE,
            ELF_MAGIC_SIGNATURE,
        );
        helper_fail(parse_elf_magic_number, b"\x7fFLF");
    }
}
```

### class

```rust
// src/elf.rs
#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]
#[repr(u8)]
pub enum ElfClass {
    None = 0,
    Bit32 = 1,
    Bit64 = 2,
    Num = 3,
    Unknown,
}

impl From<u8> for ElfClass {
    fn from(b: u8) -> ElfClass {
        match b {
            0 => ElfClass::None,
            1 => ElfClass::Bit32,
            2 => ElfClass::Bit64,
            3 => ElfClass::Num,
            _ => ElfClass::Unknown,
        }
    }
}

// src/parser/header.rs
fn parse_elf_class(raw: &[u8]) -> IResult<&[u8], ElfClass> {
    map(read_u8, |byte: u8| ElfClass::from(byte))(raw)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn elf_class_test() {
        helper(parse_elf_class, &[0x00], ElfClass::None);
        helper(parse_elf_class, &[0x01], ElfClass::Bit32);
        helper(parse_elf_class, &[0x02], ElfClass::Bit64);
        helper(parse_elf_class, &[0x03], ElfClass::Num);
        helper(parse_elf_class, &[0xff], ElfClass::Unknown);
    }
}
```

### data

```rust
// src/elf.rs
#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]
#[repr(u8)]
pub enum ElfData {
    None = 0,
    Lsb = 1,
    Msb = 2,
    Num = 3,
    Unknown,
}

impl From<u8> for ElfData {
    fn from(b: u8) -> ElfData {
        match b {
            0 => ElfData::None,
            1 => ElfData::Lsb,
            2 => ElfData::Msb,
            3 => ElfData::Num,
            _ => ElfData::Unknown,
        }
    }
}

// src/parser/header.rs
fn parse_elf_data(raw: &[u8]) -> IResult<&[u8], ElfData> {
    map(read_u8, |byte: u8| ElfData::from(byte))(raw)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn elf_data_test() {
        helper(parse_elf_data, &[0x00], ElfData::None);
        helper(parse_elf_data, &[0x01], ElfData::Lsb);
        helper(parse_elf_data, &[0x02], ElfData::Msb);
        helper(parse_elf_data, &[0x03], ElfData::Num);
        helper(parse_elf_data, &[0xff], ElfData::Unknown);
    }
}
```

### identification

上記sub parserを組み合わせてelf identificationのparserを組み立てる事ができます．  

```rust
// src/elf.rs
#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]
pub struct ElfIdentification {
    pub class: ElfClass,
    pub data: ElfData,
    pub version: ElfVersion,
    pub osabi: ElfOsAbi,
    pub abi_version: u8,
}

// src/parser/header.rs
fn parse_elf_identification(raw: &[u8]) -> IResult<&[u8], ElfIdentification> {
    let (rest, (_, class, data, version, osabi, abi_version, _)) = tuple((
        parse_elf_magic_number,
        parse_elf_class,
        parse_elf_data,
        parse_elf_version,
        parse_elf_osabi,
        parse_elf_abi_version,
        count(read_u8, 7),
    ))(raw)?;

    Ok((
        rest,
        ElfIdentification {
            class,
            data,
            version,
            osabi,
            abi_version,
        },
    ))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn elf_identification_test() {
        helper(
            parse_elf_identification,
            &[
                0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            ElfIdentification {
                class: ElfClass::Bit64,
                data: ElfData::Lsb,
                version: ElfVersion::Current,
                osabi: ElfOsAbi::SysV,
                abi_version: 0x00,
            },
        );
    }
}
```

## appendix

32bit版のheader parsingも同様に実装することができます．  
興味のある人は取り組んでみてください．  
また，elf classを読む事でparse時に32bit/64bit parserを切り替える事ができます．  
これによって自作readelfを32bit/64bitに対応させる事ができます．  
[拙作のelf-utilities](https://github.com/Drumato/elf-utilities/blob/b7e314f714dd6bb314b4afa2a7bea34967112f9d/src/parser/parse.rs#L32)でも同じようにしています．  
