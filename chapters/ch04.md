# ELF header

ELF headerとは，  
ELF fileの先頭にある，64bytes(32bit版なら52bytes)のfieldです．

file全体の情報や，{section, segment} header tableのoffsetが格納されているので，  
ELFを扱うsoftwareは例外なくこのheaderのparseから始まります．  
ということで，ELF header parserを作ってみましょう．

binary parserを作るときは，それに対応する構造体表現を作る手法が一般的です．  
C言語でELF parserを作るときは `elf.h` を使うことでその構造体を利用できますが，  
今回は構造体を手書きすることで，ELFの構造を理解するapproachを取ってみます．

各構造体メンバの意味や用途については省略します．  
こちらの資料が参考になります．

> [System Ⅴ ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)

## parser

今回はparser combinator crateのnomを使ってsimpleに実装します．  
nomについての解説は行わないので，気になる方はご自身で調べてみてください．

まずはbinary parsingによって`ElfHeader64`が得られるまでの実装をしていきます．  
いきなり答えを見せるので，それを参考にご自身で作ってみても良いですし，  
動かしてみてもいいと思います．

非常に長いですが，テストコードが殆どであり，実装自体は小さいのですぐに理解できると思います．

```rust
use crate::elf;
use nom::{
    bytes::complete::tag,
    combinator::peek,
    multi::count,
    number::complete::{le_u16, le_u32, le_u64, u8 as nom_u8},
    sequence::tuple,
    IResult,
};
pub fn parse_elf_header_64(i: &[u8]) -> IResult<&[u8], elf::ElfHeader64> {
    let (rest, id) = parse_elf_identification(i)?;
    let (
        rest,
        (
            e_type, e_machine, e_version, e_entry, e_phoff, e_shoff,
            e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize,
            e_shnum, e_shstrndx,
        ),
    ) = tuple((
        le_u16, le_u16, le_u32, le_u64, le_u64, le_u64, le_u32, le_u16, le_u16, le_u16, le_u16,
        le_u16, le_u16,
    ))(rest)?;

    let hdr = elf::ElfHeader64 {
        e_ident: id,
        e_type,
        e_machine,
        e_version,
        e_entry,
        e_phoff,
        e_shoff,
        e_flags,
        e_ehsize,
        e_phentsize,
        e_phnum,
        e_shentsize,
        e_shnum,
        e_shstrndx,
    };

    Ok((rest, hdr))
}

pub fn peek_elf_identification(i: &[u8]) -> IResult<&[u8], elf::ElfIdentification> {
    peek(parse_elf_identification)(i)
}
/// 先頭16bytes, ELF Identificationのparser
fn parse_elf_identification(i: &[u8]) -> IResult<&[u8], elf::ElfIdentification> {
    let (rest, magic_number) = parse_elf_magic_number(i)?;
    let (rest, bytes) = count(nom_u8, 5)(rest)?;

    let ident = elf::ElfIdentification {
        magic_number: [
            magic_number[0],
            magic_number[1],
            magic_number[2],
            magic_number[3],
        ],
        class: bytes[0],
        data: bytes[1],
        version: bytes[2],
        osabi: bytes[3],
        abi_version: bytes[4],
    };

    let (rest, _padding) = count(nom_u8, 7)(rest)?;

    Ok((rest, ident))
}

fn parse_elf_magic_number(i: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"\x7fELF")(i)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_elf_magic_number_test() {
        let result = parse_elf_magic_number(b"\x7fELF");
        assert!(result.is_ok());

        let result = parse_elf_magic_number(b"\x7fEEF");
        assert!(result.is_err());
    }

    #[test]
    fn parse_elf_identification_test() {
        // 適当に既存ELFの先頭16bytesをコピー
        let result = parse_elf_identification(&[
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]);
        assert!(result.is_ok());

        let (_, ident) = result.unwrap();
        assert_eq!([0x7f, b'E', b'L', b'F'], ident.magic_number);
        assert_eq!(elf::ELFCLASS64, ident.class);
        assert_eq!(elf::ELFDATA2LSB, ident.data);
        assert_eq!(elf::ELFOSABI_SYSV, ident.osabi);
        assert_eq!(0x00, ident.abi_version);
    }

    #[test]
    fn parse_elf_header_64_test() {
        let result = parse_elf_header_64(&[
            // 0x00 ~ 0x10
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            // 0x10 ~ 0x20
            0x03, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00, 
            0xd0, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            // 0x20 ~ 0x30
            0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0xc0, 0x23, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
            // 0x30 ~ 0x40
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 
            0x0d, 0x00, 0x40, 0x00, 0x1e, 0x00, 0x1d, 0x00,
        ]);
        assert!(result.is_ok());

        let ((_, hdr)) = result.unwrap();
        assert_eq!(
            elf::ElfIdentification {
                magic_number: [0x7f, 0x45, 0x4c, 0x46],
                class: elf::ELFCLASS64,
                data: elf::ELFDATA2LSB,
                version: elf::EV_CURRENT,
                osabi: elf::ELFOSABI_SYSV,
                abi_version: 0x00,
            },
            hdr.e_ident
        );

        assert_eq!(0x03, hdr.e_type);
        assert_eq!(0x3e, hdr.e_machine);
        assert_eq!(1, hdr.e_version);
        assert_eq!(0x67d0, hdr.e_entry);
        assert_eq!(0x40, hdr.e_phoff);
        assert_eq!(140224, hdr.e_shoff);
        assert_eq!(0x0, hdr.e_flags);
        assert_eq!(0x40, hdr.e_ehsize);
        assert_eq!(0x38, hdr.e_phentsize);
        assert_eq!(13, hdr.e_phnum);
        assert_eq!(0x40, hdr.e_shentsize);
        assert_eq!(30, hdr.e_shnum);
        assert_eq!(29, hdr.e_shstrndx);
    }
}
```

32bit版のheader parsingも同様に実装することができます．  
興味のある人は取り組んでみてください．
